
// This is an autogenerated file from Firebase Studio.
'use server';

import { db } from '@/lib/db';
import type { Product, Sale, Customer, Expense, Settings, LogSaleFormValues } from "@/lib/types";

// === READ OPERATIONS ===

export async function getProducts(): Promise<Product[]> {
    return db.prepare("SELECT * FROM products ORDER BY name ASC").all() as Product[];
}

export async function getSales(): Promise<Sale[]> {
    return db.prepare("SELECT * FROM sales ORDER BY date DESC").all() as Sale[];
}

export async function getCustomers(): Promise<Customer[]> {
    return db.prepare("SELECT * FROM customers ORDER BY name ASC").all() as Customer[];
}

export async function getExpenses(): Promise<Expense[]> {
    return db.prepare("SELECT * FROM expenses ORDER BY date DESC").all() as Expense[];
}

export async function getSettings(): Promise<Settings> {
    const defaultSettings: Settings = {
        businessName: "My Business",
        currency: "USD",
        enableAssistant: true,
        autoSuggestions: true,
        language: "en",
    };
    
    const settingsFromDb = db.prepare("SELECT value FROM settings WHERE key = ?").get('appSettings') as { value: string } | undefined;
    
    if (settingsFromDb) {
        return JSON.parse(settingsFromDb.value);
    } else {
        db.prepare("INSERT INTO settings (key, value) VALUES (?, ?)").run('appSettings', JSON.stringify(defaultSettings));
        return defaultSettings;
    }
}

export async function getInitialData() {
    return {
        products: await getProducts(),
        sales: await getSales(),
        customers: await getCustomers(),
        expenses: await getExpenses(),
        settings: await getSettings(),
    }
}


// === WRITE OPERATIONS ===

export async function addProduct(productData: Omit<Product, "id" | "lastUpdatedAt">): Promise<Product> {
    const newProduct = {
      ...productData,
      lastUpdatedAt: new Date().toISOString(),
    };
    const result = db.prepare(`
        INSERT INTO products (name, description, stock, price, cost, category, supplier, lastUpdatedAt) 
        VALUES (@name, @description, @stock, @price, @cost, @category, @supplier, @lastUpdatedAt)
    `).run(newProduct);
    return { ...newProduct, id: result.lastInsertRowid.toString() };
}

export async function updateProduct(updatedProduct: Product): Promise<Product> {
    const productToUpdate = { ...updatedProduct, lastUpdatedAt: new Date().toISOString() };
    db.prepare(`
        UPDATE products SET 
            name = @name, description = @description, stock = @stock, price = @price, cost = @cost, 
            category = @category, supplier = @supplier, lastUpdatedAt = @lastUpdatedAt
        WHERE id = @id
    `).run(productToUpdate);
    return productToUpdate;
}

export async function receiveStock(productId: string, quantity: number, costPerUnit: number): Promise<Product> {
    const product = db.prepare("SELECT * FROM products WHERE id = ?").get(productId) as Product | undefined;
    if (!product) throw new Error("Product not found");

    const currentStock = Number(product.stock) || 0;
    const currentCost = Number(product.cost) || 0;
    if (quantity <= 0) return product;

    const newStock = currentStock + quantity;
    const newAverageCost = newStock > 0
      ? ((currentCost * currentStock) + (costPerUnit * quantity)) / newStock
      : costPerUnit;
      
    const updatedProduct: Product = {
        ...product,
        stock: newStock,
        cost: isNaN(newAverageCost) ? currentCost : newAverageCost,
        lastUpdatedAt: new Date().toISOString(),
    };

    return await updateProduct(updatedProduct);
}


export async function addSale(saleData: LogSaleFormValues): Promise<{ newSale: Sale, updatedProduct: Product }> {
    const product = db.prepare("SELECT * FROM products WHERE id = ?").get(saleData.productId) as Product | undefined;
    if (!product) throw new Error("Product not found");
    if (product.stock < saleData.quantity) throw new Error("Not enough stock");

    let customerName = "Walk-in Customer";
    if (saleData.customerId && saleData.customerId !== 'walk-in') {
        const customer = db.prepare("SELECT * FROM customers WHERE id = ?").get(saleData.customerId) as Customer | undefined;
        if(customer) customerName = customer.name;
    }

    const profit = (saleData.pricePerUnit - product.cost) * saleData.quantity;
    const total = saleData.pricePerUnit * saleData.quantity;

    const newSaleData: Omit<Sale, "id"> = {
      productId: saleData.productId,
      productName: product.name,
      customerName,
      customerId: saleData.customerId,
      quantity: saleData.quantity,
      pricePerUnit: saleData.pricePerUnit,
      total,
      profit,
      notes: saleData.notes,
      date: new Date().toISOString(),
    };
    
    const result = db.prepare(`
        INSERT INTO sales (productId, customerId, customerName, productName, quantity, pricePerUnit, total, profit, notes, date) 
        VALUES (@productId, @customerId, @customerName, @productName, @quantity, @pricePerUnit, @total, @profit, @notes, @date)
    `).run(newSaleData);
    const newSale = { ...newSaleData, id: result.lastInsertRowid.toString() };
    
    const updatedProductData = { ...product, stock: product.stock - saleData.quantity, lastUpdatedAt: new Date().toISOString() };
    const updatedProduct = await updateProduct(updatedProductData);

    return { newSale, updatedProduct };
}


export async function addCustomer(customerData: Omit<Customer, "id" | "createdAt">): Promise<Customer> {
    const newCustomerData = {
      ...customerData,
      createdAt: new Date().toISOString(),
      type: customerData.type || "Regular",
      notes: customerData.notes || null,
    };
    const result = db.prepare(`
        INSERT INTO customers (name, phone, createdAt, notes, type) 
        VALUES (@name, @phone, @createdAt, @notes, @type)
    `).run(newCustomerData);
    const newCustomer = { ...newCustomerData, id: result.lastInsertRowid.toString() };
    return newCustomer;
}


export async function updateCustomer(updatedCustomer: Customer): Promise<Customer> {
    db.prepare(`
        UPDATE customers SET name = @name, phone = @phone, notes = @notes, type = @type
        WHERE id = @id
    `).run(updatedCustomer);
    return updatedCustomer;
}

export async function addExpense(expenseData: Omit<Expense, "id" | "date">): Promise<Expense> {
    const newExpenseData: Omit<Expense, "id"> = { ...expenseData, date: new Date().toISOString() };
    const result = db.prepare(`
        INSERT INTO expenses (description, category, amount, date, notes) 
        VALUES (@description, @category, @amount, @date, @notes)
    `).run(newExpenseData);
    return { ...newExpenseData, id: result.lastInsertRowid.toString() };
}

export async function updateExpense(updatedExpense: Expense): Promise<Expense> {
    const expenseToUpdate = { ...updatedExpense, date: new Date().toISOString() };
    db.prepare(`
        UPDATE expenses SET description = @description, category = @category, amount = @amount, date = @date, notes = @notes
        WHERE id = @id
    `).run(expenseToUpdate);
    return expenseToUpdate;
}


export async function deleteExpense(id: string): Promise<{ success: boolean }> {
    db.prepare("DELETE FROM expenses WHERE id = ?").run(id);
    return { success: true };
}


export async function updateSettings(newSettings: Settings): Promise<Settings> {
    db.prepare("UPDATE settings SET value = ? WHERE key = ?").run(JSON.stringify(newSettings), 'appSettings');
    return newSettings;
}
